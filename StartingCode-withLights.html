<html lang="en">
	<head>
		<title>Cubes world 2019 #zottino-petricig-lenzi-fork</title>
		<link rel="stylesheet" type="text/css" href="styles/styles.css"/>
        <!-- LIBRARIES -->
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/controls/UIControls.js"></script>
	</head>

	<body onclick="uiControls.unfreeze();" ondblclick="uiControls.freeze();">
        <!-- Creation of the scene freezer.  -->
		<div id="sceneFreezer">
            <!-- Display initial instructions menu -->
			<div id="instructionsMenu">
                <span id="title">Click to PLAY</span>
                <br/>
				(CLICK) = PLAY! <br/>
                (UP/W, LEFT/A, RIGHT/D, DOWN/S) = Move <br/>
                (MOUSE) = Look around <br/>
            </div>
		</div>

		<script>
            /* GLOBALS */
            var scene, camera, hemsLight, dirLight, renderer, stats;

            //var objects = [];

            var vertex = new THREE.Vector3();
            var color = new THREE.Color();
            var colors = [];

            // === ALEKSEJ ===========================================
            var uiControls;

            var direction = new THREE.Vector3();
            var velocity = new THREE.Vector3();
            var prevTime = performance.now();
            var moveForward = false;
            var moveBackward = false;
            var moveLeft = false;
            var moveRight = false;
            var exit = false;
			var onTheGround;
			var canFly;
            var raycaster;
            var objects = [];

            /*
             *  This object represents and contains the scene additional objects/characteristics that compose
             *  the scene.
             *
             *  Object is written as name:value pairs. (JSON style)
             */
            var characteristics = {
                camera: new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 ),
                light: new THREE.HemisphereLight( 0xffff66, 0xffcc00, 0.75 ),
                fog: new THREE.Fog( 0xffffff, 20, 400 )
            };

            /*
             *  This method sets up the scene.
             *
             *  1] Setup background scene color
             *  2] Addition of the fog to the scene
             *
             *  @param scene: the scene to be set up
             */
            function sceneSetup( scene ) {
                scene.background = new THREE.Color( 0x7EAFDB );
                scene.fog = characteristics['fog'];
            }

            /*
             *  This method sets up the scene.
             *
             *  1] Setup the camera position
             *  2] Setup of the view-vector (look-at point)
             *
             *  @param scene: the scene to be set up
             */
            function cameraSetup( camera ) {
                camera.position.set(6,6,36);
                camera.lookAt( new THREE.Vector3(0,0,0));
            }

            /*
             *  This method sets up the scene light.
             *
             *  1] Setup light's position
             *  2] Addition of the hemisphere light to the scene
             *
             *  @param light: the light to be added to the scene
             */
            function lightSetup( light ) {
                light.position.set( 0.5, 1, 0.75 );
                scene.add( light );
            }

            /*
             *  This method inits the scene, camera and light.
             *  Here we have the preparation of the scene variables and objects.
             */
		    function Start() {
                scene = new THREE.Scene();
                // 2] Declaration and initialization of the camera
                camera = characteristics['camera'];
                // 3] Declaration and initialization of the hemisphere light
                hemsLight = characteristics['light'];

                sceneSetup(scene);
                cameraSetup(camera);
                lightSetup(hemsLight);

                /*
                 *  Initialization of the controls of the scene.
                 *  + Inclusion of the camera into che scene
                 *  + Activation of the movements variables that allows ui-controls
                 *
                 *  @param camera: the camera of the scene
                 *  @param anonymous function () => {...} (ES6) witch sets control's params to 'true' each uiControls variables
                 *
                 *  Source:  https://github.com/mrdoob/three.js/blob/master/examples/misc_controls_pointerlock.html
                 */
                uiControls = new UIControls( camera, document.body );

				/*
                 * @author Alek6 / http://aleksejpetricig.wordpress.com/
                 * @author Alek6 / https://github.com/Alek6
                 */

                /* MENU' INIZIALE */
                //var sceneFreezer = document.getElementById('sceneFreezer');
                //var instructionsMenu = document.getElementById('instructionsMenu');

                /*
                *  Addition of an EventListener on 'click' to the instructions menu
                *
                *  > Hiding of the scene freezer menu of UIControls instructions on 'click' event
                *  > uiControls locking
                */
                /*
                instructionsMenu.addEventListener( 'click', () => {
                    uiControls.freeze();
                }, false );
                */

                /*
                *  Addition of an EventListener on 'unfreeze'to the instructions menu
                *
                *  > uiControls melt
                *  > Unfreeze the scene menu of UIControls instructions on 'unfreeze' event
                */


                /*
                 *  Addiction of the uiControls object to the scene
                 */
                scene.add( uiControls.getObject() );

                // === ALEKSEJ ===========================================

                // floor
                var floorGeometry = new THREE.PlaneBufferGeometry(2800, 2800, 100, 100);
                floorGeometry.rotateX(-Math.PI / 2);

                // Vertex displacement
                var position = floorGeometry.attributes.position;

                for (let i = 0, l = position.count; i < l; i++) {
                    vertex.fromBufferAttribute(position, i);
                    vertex.x += Math.random() * 20 - 10;
                    vertex.y += Math.random() * 2;
                    vertex.z += Math.random() * 20 - 10;
                    position.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }

                floorGeometry = floorGeometry.toNonIndexed(); // ensure each face has unique vertices

                position = floorGeometry.attributes.position;

                for (let i = 0, l = position.count; i < l; i++) {
                    color.setHSL(Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75);
                    colors.push(color.r, color.g, color.b);
                }

                floorGeometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                var floorMaterial = new THREE.MeshBasicMaterial({vertexColors: THREE.VertexColors});
                var floor = new THREE.Mesh(floorGeometry, floorMaterial);

                scene.add(floor);

                // ====================================================================
				var geometry = new THREE.BoxGeometry(10,10,10);
				var texture = THREE.ImageUtils.loadTexture('textures/11635.jpg');
				var material = new THREE.MeshPhongMaterial( { map: texture } );
				var cube = new THREE.Mesh( geometry, material );
				// Setting up the cube's shadow
				cube.castShadow = true;
				cube.receiveShadow = true;
				cube.position.set(0,7,0);

				scene.add( cube );
				objects.push( cube );

				/*hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
				hemiLight.color.setHSL( 0.6, 1, 0.6 );
				hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
				hemiLight.position.set( 0, 500, 0 );
				scene.add( hemiLight ); */

				// DIRECTIONAL LIGHT
				dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
				dirLight.color.setHSL( 0.1, 1, 0.95 );
				dirLight.position.set(-1, 1.75, 1);
				dirLight.position.multiplyScalar( 50 );
				scene.add( dirLight );
				dirLight.castShadow = true;
				dirLight.shadow.mapSize.width = 1024;
				dirLight.shadow.mapSize.height = 1024;

				// STATS
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				document.body.appendChild( stats.domElement );

                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0xf0f0f0);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.gammaInput = true;
                renderer.gammaOutput = true;
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement);

                window.addEventListener('resize', onWindowResize, false);
            } // fine-init()

            // ON WINDOW RESIZE
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            // ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
            // KEYBOARD COMMANDS
            function Move() {
                requestAnimationFrame( Move );
                const HEAD = uiControls.getObject();
                if ( uiControls.isFreezed === false ) {
                    raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);
                    raycaster.ray.origin.copy( HEAD.position );
                    raycaster.ray.origin.y -= 10;
                    var intersections = raycaster.intersectObjects( objects );
                    var onObject = intersections.length > 0;
                    var time = performance.now();
                    var delta = ( time - prevTime ) / 1000;
                    velocity.x -= velocity.x * 10.0 * delta;
                    velocity.z -= velocity.z * 10.0 * delta;
                    velocity.y -= 9.8 * 100.0 * delta;
                    direction.z = Number( moveForward ) - Number( moveBackward );
                    direction.x = Number( moveLeft ) - Number( moveRight );

					// Setup linear movements in all directions
                    direction.normalize();

                    // Changing of the velocity variable of different movement directions
					if ( moveForward || moveBackward ) {
                        velocity.z -= direction.z * 400.0 * delta;
                    }
                    if ( moveLeft || moveRight ) {
                        velocity.x -= direction.x * 400.0 * delta;
                    }
                    if( ' ' ) {
                        velocity.y -= direction.y * 400.0 * delta;
                    }

                    // Collision with a scene object (any cube)
                    if ( onObject === true ) {
                        velocity.y = Math.max( 0, velocity.y );
                        canFly = true;
                        console.log( "Collision!!" );
                    }

                    // MOVEMENTS ON XYZ AXIS
                    HEAD.translateX( velocity.x * delta );
                    HEAD.translateY( velocity.y * delta );
                    HEAD.translateZ( velocity.z * delta );

                    if ( HEAD.position.y < 10 ) {
                        onTheGround = true;
                        canFly = true;
                        HEAD.position.y = 0;
                    }
                    prevTime = time;
                }
                renderer.render( scene, camera );
            } // _move()
            // ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

            //uiControls = new UIControls( characteristics.camera, document.body );

	        /*
	         *  ::: Public methods :::
	         *
	         *  Method for the scene and objects Update.
	         */
		    function Update() {
			    requestAnimationFrame( Update );
			    stats.update();
			    Render();
		    }

            /*
             *  Method for the scene Rendering.
             */
            function Render() {
                renderer.render( scene, camera );
            }

		    Start();
            Move();
		    Update();

		</script>
	</body>
</html>